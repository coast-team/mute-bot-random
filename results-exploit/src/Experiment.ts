import { LogootSOperation, LogootSRopes, TextDelete, TextInsert, TextOperation } from 'mute-structs'
const fs = require('fs')

export class Experiment {
  private result: ILogs[]
  private sequence: string

  private nbOperation: number

  constructor(file: string, nbOperation: number) {
    this.sequence = JSON.parse(fs.readFileSync('./input/' + file).toString())
    console.log(this.sequence.length)
    this.result = []
    this.nbOperation = nbOperation
  }

  public start() {
    for (let i = 0; i < this.nbOperation; i++) {
      // LOCAL
      // Generate the sequence
      const seq = LogootSRopes.fromPlain(this.sequence)
      if (!seq) {
        throw new Error('FromPLain is null' + seq)
      }

      // Generate a local operation
      const local = this.generateLocal(seq.str.length)

      // Apply
      let tLocalBefore: [number, number]
      let tLocalAfter: [number, number]
      let remote: LogootSOperation
      if (local instanceof TextInsert) {
        tLocalBefore = process.hrtime()
        remote = local.applyTo(seq)
        tLocalAfter = process.hrtime()
      } else if (local instanceof TextDelete) {
        tLocalBefore = process.hrtime()
        remote = local.applyTo(seq)
        tLocalAfter = process.hrtime()
      } else {
        throw new Error('local is not an instance of TextInsert or TextDelete')
      }

      // REMOTE
      // Generate the sequence
      const seq2 = LogootSRopes.fromPlain(this.sequence)
      if (!seq2) {
        throw new Error('FromPLain Remote is null')
      }

      // Apply
      const tRemoteBefore = process.hrtime()
      remote.execute(seq2)
      const tRemoteAfter = process.hrtime()

      this.result.push({ local, remote, tLocalBefore, tLocalAfter, tRemoteBefore, tRemoteAfter })
    }

    fs.writeFileSync('output/result.json', JSON.stringify(this.result))
  }

  private generateLocal(indexMax: number): TextOperation {
    const de = this.random(100)
    if (de > 50) {
      return new TextInsert(this.random(indexMax), 'I', 1000)
    } else {
      return new TextDelete(this.random(indexMax - 1), 1, 1000)
    }
  }

  private random(max: number) {
    return Math.floor(Math.random() * (max + 1))
  }
}

export interface ILogs {
  local: TextOperation
  remote: LogootSOperation
  tLocalBefore: [number, number]
  tLocalAfter: [number, number]
  tRemoteBefore: [number, number]
  tRemoteAfter: [number, number]
}
