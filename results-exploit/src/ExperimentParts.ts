import { LogootSOperation, LogootSRopes, TextDelete, TextInsert, TextOperation } from 'mute-structs'
const fs = require('fs')

export enum OperationType {
  INSERT,
  DELETE,
}

export interface ILogs {
  local: TextOperation
  remote: LogootSOperation
  tLocalBefore: [number, number]
  tLocalAfter: [number, number]
  tRemoteBefore: [number, number]
  tRemoteAfter: [number, number]
}

export class ExperimentParts {
  private name: string
  private sequence: LogootSRopes

  private operationType: OperationType
  private nbChar: number
  private nbTimes: number
  private content: string

  constructor(name: string, sequence: any, type: OperationType, nbChar: number, nbTimes: number) {
    this.name = name
    this.sequence = sequence
    this.operationType = type
    this.nbChar = 0
    this.nbTimes = 0
    this.content = ''

    for (let i = 0; i < nbChar; i++) {
      this.content += 'I'
    }

    this.setNbChar(nbChar)
    this.setNbTimes(nbTimes)
  }

  public launch() {
    console.log(`Start : ${this.name} (${this.operationType}, ${this.nbChar})`)
    const results: ILogs[] = []
    let progress = 5
    const startTime = process.hrtime()
    for (let i = 0; i < this.nbTimes; i++) {
      const seq = LogootSRopes.fromPlain(this.sequence)
      if (!seq) {
        throw new Error('Sequence from plain null')
      }
      const local = this.generateLocal(seq.str.length)

      // Apply
      let tLocalBefore: [number, number]
      let tLocalAfter: [number, number]
      let remote: LogootSOperation

      tLocalBefore = process.hrtime()
      remote = local.applyTo(seq)
      tLocalAfter = process.hrtime()

      // Generate the sequence
      const seq2 = LogootSRopes.fromPlain(this.sequence)
      if (!seq2) {
        throw new Error('FromPLain Remote is null')
      }

      const tRemoteBefore = process.hrtime()
      remote.execute(seq2)
      const tRemoteAfter = process.hrtime()

      results.push({ local, remote, tLocalBefore, tLocalAfter, tRemoteBefore, tRemoteAfter })
      const percent = Math.floor(((i + 1) / this.nbTimes) * 100)
      if (percent > 0 && percent % progress === 0) {
        const progressTime = process.hrtime(startTime)
        console.log('Progress :', percent, `(${i + 1}/${this.nbTimes} in ${progressTime})`)
        progress += 5
      }
    }
    const stopTime = process.hrtime(startTime)

    fs.writeFileSync(`output/${this.name}.json`, JSON.stringify(results))
    console.log(`End : ${this.name} in ${stopTime}s`)
  }

  private generateLocal(indexMax: number): TextOperation {
    switch (this.operationType) {
      case OperationType.INSERT:
        const iIndex = this.random(indexMax)
        return new TextInsert(iIndex, this.content, 1000)
      case OperationType.DELETE:
        const dIndex = this.random(indexMax - this.nbChar)
        return new TextDelete(dIndex, this.nbChar, 1000)
      default:
        throw new Error(`Type ${this.operationType} doesn't exist.`)
    }
  }

  private random(max: number) {
    return Math.floor(Math.random() * (max + 1))
  }

  private setNbChar(nb: number) {
    if (nb > 0) {
      this.nbChar = nb
    } else {
      console.log('Error : nbChar <= 0 ... set to 1')
      this.nbChar = 1
    }
  }

  private setNbTimes(nb: number) {
    if (nb > 0) {
      this.nbTimes = nb
    } else {
      console.log('Error : nbTimes <= 0 ... set to 100')
      this.nbTimes = 100
    }
  }
}
