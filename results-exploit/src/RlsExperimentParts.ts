import {
  LogootSOperation,
  RenamableLogootSAdd,
  RenamableLogootSDel,
  RenamableLogootSOperation,
  RenamableReplicableList,
  TextDelete,
  TextInsert,
  TextOperation,
} from 'mute-structs'
const fs = require('fs')

export enum OperationType {
  INSERT,
  DELETE,
}

export interface IRlsLogs {
  local: TextOperation
  remote: RenamableLogootSOperation<LogootSOperation>
  remoteNewEpoch: RenamableLogootSOperation<LogootSOperation>
  tLocalBefore: [number, number]
  tLocalAfter: [number, number]
  tRemoteBefore: [number, number]
  tRemoteAfter: [number, number]
  tLocalOnRenameBefore: [number, number]
  tLocalOnRenameAfter: [number, number]
  tRemotePastOnRenameBefore: [number, number]
  tRemotePastOnRenameAfter: [number, number]
  tRemoteOnRenameBefore: [number, number]
  tRemoteOnRenameAfter: [number, number]
}

export class RlsExperimentParts {
  private name: string
  private sequence: RenamableReplicableList

  private operationType: OperationType
  private nbChar: number
  private nbTimes: number
  private content: string

  constructor(name: string, sequence: any, type: OperationType, nbChar: number, nbTimes: number) {
    this.name = name
    this.sequence = sequence
    this.operationType = type
    this.nbChar = 0
    this.nbTimes = 0
    this.content = ''

    for (let i = 0; i < nbChar; i++) {
      this.content += 'I'
    }

    this.setNbChar(nbChar)
    this.setNbTimes(nbTimes)
  }

  public launch() {
    console.log(`Start : ${this.name} (${this.operationType}, ${this.nbChar})`)
    const results: IRlsLogs[] = []
    let progress = 5

    // Renaming
    const seqRename = RenamableReplicableList.fromPlainLogootSRopes(this.sequence)
    if (!seqRename) {
      throw new Error('FromPlain BeforeRename is null')
    }
    seqRename.renameLocal()
    const plainSeqRename = JSON.parse(JSON.stringify(seqRename))
    seqRename.renamingMapStore.purge()
    const plainSeqRenameWithoutRenamingMaps = JSON.parse(JSON.stringify(seqRename))

    const startTime = process.hrtime()
    for (let i = 0; i < this.nbTimes; i++) {
      const seq = RenamableReplicableList.fromPlainLogootSRopes(this.sequence)
      if (!seq) {
        throw new Error('Sequence from plain null')
      }
      const local = this.generateLocal(seq.str.length)

      // Local on Initial seq
      const tLocalBefore = process.hrtime()
      const remote = this.applyTextOp(seq, local)
      const tLocalAfter = process.hrtime()

      // Remote on Initial seq
      const seq2 = RenamableReplicableList.fromPlainLogootSRopes(this.sequence)
      if (!seq2) {
        throw new Error('FromPlain Remote is null')
      }
      const tRemoteBefore = process.hrtime()
      remote.execute(seq2)
      const tRemoteAfter = process.hrtime()

      // Remote on Renamed seq
      const seq3 = RenamableReplicableList.fromPlain(plainSeqRename)
      if (!seq3) {
        throw new Error('Sequence3 from plain null')
      }
      const tRemotePastOnRenameBefore = process.hrtime()
      remote.execute(seq3)
      const tRemotePastOnRenameAfter = process.hrtime()

      // Local on Renamed seq
      const seq4 = RenamableReplicableList.fromPlain(plainSeqRenameWithoutRenamingMaps)
      if (!seq4) {
        throw new Error('Sequence4 from plain null')
      }
      const tLocalOnRenameBefore = process.hrtime()
      const remoteNewEpoch = this.applyTextOp(seq4, local)
      const tLocalOnRenameAfter = process.hrtime()

      // Remote on Renamed seq
      const seq5 = RenamableReplicableList.fromPlain(plainSeqRenameWithoutRenamingMaps)
      if (!seq5) {
        throw new Error('Sequence5 from plain null')
      }
      const tRemoteOnRenameBefore = process.hrtime()
      remoteNewEpoch.execute(seq5)
      const tRemoteOnRenameAfter = process.hrtime()

      // PUSH RESULTS
      results.push({
        local,
        remote,
        remoteNewEpoch,
        tLocalBefore,
        tLocalAfter,
        tRemoteBefore,
        tRemoteAfter,
        tLocalOnRenameBefore,
        tLocalOnRenameAfter,
        tRemotePastOnRenameBefore,
        tRemotePastOnRenameAfter,
        tRemoteOnRenameBefore,
        tRemoteOnRenameAfter,
      })
      const percent = Math.floor(((i + 1) / this.nbTimes) * 100)
      if (percent > 0 && percent % progress === 0) {
        const progressTime = process.hrtime(startTime)
        console.log('Progress :', percent, `(${i + 1}/${this.nbTimes} in ${progressTime})`)
        progress += 5
      }
    }
    const stopTime = process.hrtime(startTime)

    fs.writeFileSync(`output/${this.name}.json`, JSON.stringify(results))
    console.log(`End : ${this.name} in ${stopTime}s`)
  }

  private generateLocal(indexMax: number): TextInsert | TextDelete {
    switch (this.operationType) {
      case OperationType.INSERT:
        const iIndex = this.random(indexMax)
        return new TextInsert(iIndex, this.content, 1000)
      case OperationType.DELETE:
        const dIndex = this.random(indexMax - this.nbChar)
        return new TextDelete(dIndex, this.nbChar, 1000)
      default:
        throw new Error(`Type ${this.operationType} doesn't exist.`)
    }
  }

  private applyTextOp(
    seq: RenamableReplicableList,
    textOp: TextInsert | TextDelete
  ): RenamableLogootSAdd | RenamableLogootSDel {
    if (textOp instanceof TextInsert) {
      return seq.insertLocal(textOp.index, textOp.content)
    } else {
      return seq.delLocal(textOp.index, textOp.index + textOp.length - 1)
    }
  }

  private random(max: number) {
    return Math.floor(Math.random() * (max + 1))
  }

  private setNbChar(nb: number) {
    if (nb > 0) {
      this.nbChar = nb
    } else {
      console.log('Error : nbChar <= 0 ... set to 1')
      this.nbChar = 1
    }
  }

  private setNbTimes(nb: number) {
    if (nb > 0) {
      this.nbTimes = nb
    } else {
      console.log('Error : nbTimes <= 0 ... set to 100')
      this.nbTimes = 100
    }
  }
}
