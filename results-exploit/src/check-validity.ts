import { createHash } from "crypto"
import { readFile } from "fs/promises"

const folders = [
    // "1593525002",
    // "1593525204",
    // "1593525518",
    // "1593526494",
    // "1594043801",
    // "1594043929",
    // "1594044020",
    // "1594044164",
    "1594044965"
]

function md5 (str: string): string {
    return createHash("md5").update(str).digest("hex")
}

async function readFiles (filesPaths: string[]): Promise<string[]> {
    return Promise.all(filesPaths.map((filePath) => {
        return readFile(filePath, "utf8")
    }))
}

async function checkConvergence (folder: string): Promise<boolean> {
    const filesPaths = Array.from({ length: 4 }).map((_, index) => {
        return `../wip-results/${folder}/string.Bot${index}.txt`
    })
    const strings = await readFiles(filesPaths)
    const hashes = strings.map(md5)
    const expectedHash = hashes[0]
    const areConvergent = hashes.every((actualHash) => actualHash === expectedHash)
    if (!areConvergent) {
        console.error("checkConvergence(): observed a divergence in the final states")
        hashes.forEach((hash, index) => {
            console.error(`${index}: ${hash}`)
        })
    }
    return areConvergent
}

function areOpsConcurrent (vector1: Map<number, number>, vector2: Map<number, number>): boolean {
    // ops are concurrent if issued from the same state or from concurrent states
    return vector1.size !== vector2.size || areEquals(vector1, vector2) || (isGreater(vector1, vector2) && isGreater(vector2, vector1))
}

function areEquals (vector1: Map<number, number>, vector2: Map<number, number>): boolean {
    const keys = Array.from(vector1.keys())
    return keys.every((key) => {
        return vector1.get(key) === vector2.get(key)
    })
}

function isGreater (vector1: Map<number, number>, vector2: Map<number, number>): boolean {
    const keys = Array.from(vector1.keys())
    return keys.some((key) => {
        const val1 = vector1.get(key) as number
        const val2 = vector2.get(key)
        return val2 === undefined || val1 > val2
    })
}

async function retrieveRenameOpsOfBot (folder: string, index: number): Promise<any[]> {
    const filePath = `../wip-results/${folder}/Logs.Bot${index}.json`
    const logs = JSON.parse(await readFile(filePath, "utf8"))
    return logs.filter((logEntry: any) => logEntry.type === "local" && logEntry.operation.operation.renamedIdIntervals)
}

function checkNumberRenameOps (renameOpsPerBot: any[][]): boolean {
    const isNumberOfRenameOpsValid = renameOpsPerBot.every((renameOps: any[]) => renameOps.length === 4)
    if (!isNumberOfRenameOpsValid) {
        console.log("checkNumberRenameOps(): observed an invalid number of rename ops")
        renameOpsPerBot.forEach((renameOps, index) => {
            console.log(`${index}: ${renameOps.length}`)
        })
    }
    return isNumberOfRenameOpsValid
}

function checkConcurrence (renameOpsPerBot: any[][]): boolean {
    const nbRenameOps = 4
    const vectorsPerBot = renameOpsPerBot.map((renameOps) => renameOps.map((renameOp) => new Map<number, number>(renameOp.vector)))
    let areRenameOpsConcurrent = true
    for (let i = 0; i < nbRenameOps; i++) {
        for (let j = 0; j < vectorsPerBot.length - 1; j++) {
            const currentVector = vectorsPerBot[j][i]
            for (let k = j + 1; k < vectorsPerBot.length; k++) {
                const otherVector = vectorsPerBot[k][i]
                if (!areOpsConcurrent(currentVector, otherVector)) {
                    if (areRenameOpsConcurrent) {
                        console.log("checkConcurrence(): observed causal rename operations")
                        areRenameOpsConcurrent = false
                    }
                    console.log("currentVector: ", currentVector)
                    console.log("otherVector: ", otherVector)
                }
            }
        }
    }
    return areRenameOpsConcurrent
}

export async function checkValidity () {
    folders.forEach(async (folder) => {
        const areDocsConvergent = await checkConvergence(folder)
        const renameOpsPerBot = await Promise.all(Array.from({ length: 4 }).map((_, index) => retrieveRenameOpsOfBot(folder, index)))
        const isNumberOfRenameOpsValid = checkNumberRenameOps(renameOpsPerBot)
        if (isNumberOfRenameOpsValid) {
            const areRenameOpsConcurrent = checkConcurrence(renameOpsPerBot)
            console.log(`${folder}: areDocsConvergent = ${areDocsConvergent}, isNumberOfRenameOpsValid = true, areRenameOpsConcurrent = ${areRenameOpsConcurrent}`)
        } else {
            console.log(`${folder}: areDocsConvergent = ${areDocsConvergent}, isNumberOfRenameOpsValid = false`)
        }
    })

}
