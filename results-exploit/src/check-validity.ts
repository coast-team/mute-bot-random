import { createHash } from "crypto"
import { readFile } from "fs/promises"

// folders simulations with 4 renamingBots
const nbRenamingBots = 4
const folders = [
    "1594392615",
    "1595786402",
    "1594922401",
    "1595095201",
    "1594836001",
    "1594663201",
    "1595268002",
    "1594490401",
    "1595527201",
    "1595181601",
    "1595872801",
    "1595440802",
    "1594749601",
    "1594406971",
    "1595959201",
    "1594455838",
    "1595354402",
    "1595700001",
    "1595613601",
    "1594576801",
    "1595008801"
]

// folders simulations with 3 renamingBots
// const nbRenamingBots = 3
// const folders = [
//     "1595944802",
//     "1595080801",
//     "1594562401",
//     "1595426401",
//     "1595253601",
//     "1595599201",
//     "1594735201",
//     "1594821601",
//     "1595167201",
//     "1594476001",
//     "1595858402",
//     "1595340002",
//     "1595512801",
//     "1594994401",
//     "1595685601",
//     "1595772002",
//     "1594648801",
//     "1594908001"
// ]

// folders simulations with 2 renamingBots
// const nbRenamingBots = 2
// const folders = [
//     "1594634401",
//     "1595239202",
//     "1595066402",
//     "1595584801",
//     "1594461601",
//     "1594807201",
//     "1595930401",
//     "1594548002",
//     "1595844001",
//     "1594980001",
//     "1595757601",
//     "1595412001",
//     "1594720802",
//     "1594893601",
//     "1595325601",
//     "1595152801",
//     "1595671202",
//     "1595498401"
// ]

// folders simulations with 1 renamingBot
// const nbRenamingBots = 1
// const folders = [
//     "1595829602",
//     "1594879201",
//     "1595656801",
//     "1595570402",
//     "1596002401",
//     "1594533601",
//     "1595916001",
//     "1595397602",
//     "1594792802",
//     "1594965601",
//     "1595743201",
//     "1595138401",
//     "1595224801",
//     "1594620002",
//     "1595311202",
//     "1595052001",
//     "1594706401",
//     "1595484001"
// ]

function md5 (str: string): string {
    return createHash("md5").update(str).digest("hex")
}

async function readFiles (filesPaths: string[]): Promise<string[]> {
    return Promise.all(filesPaths.map((filePath) => {
        return readFile(filePath, "utf8")
    }))
}

async function checkConvergence (path: string, nbBots: number): Promise<boolean> {
    const filesPaths = Array.from({ length: nbBots }).map((_, index) => {
        return `${path}/string.Bot${index}.txt`
    })
    const strings = await readFiles(filesPaths)
    const hashes = strings.map(md5)
    const expectedHash = hashes[0]
    const areConvergent = hashes.every((actualHash) => actualHash === expectedHash)
    if (!areConvergent) {
        console.error("checkConvergence(): observed a divergence in the final states")
        hashes.forEach((hash, index) => {
            console.error(`${index}: ${hash}`)
        })
    }
    return areConvergent
}

function areOpsConcurrent (vector1: Map<number, number>, vector2: Map<number, number>): boolean {
    // ops are concurrent if issued from the same state or from concurrent states
    return vector1.size !== vector2.size || areEquals(vector1, vector2) || (isGreater(vector1, vector2) && isGreater(vector2, vector1))
}

function areEquals (vector1: Map<number, number>, vector2: Map<number, number>): boolean {
    const keys = Array.from(vector1.keys())
    return keys.every((key) => {
        return vector1.get(key) === vector2.get(key)
    })
}

function isGreater (vector1: Map<number, number>, vector2: Map<number, number>): boolean {
    const keys = Array.from(vector1.keys())
    return keys.some((key) => {
        const val1 = vector1.get(key) as number
        const val2 = vector2.get(key)
        return val2 === undefined || val1 > val2
    })
}

async function retrieveRenameOpsOfBot (path: string, index: number): Promise<any[]> {
    const filePath = `${path}/Logs.Bot${index}.json`
    const logs = JSON.parse(await readFile(filePath, "utf8"))
    return logs.filter((logEntry: any) => logEntry.type === "local" && logEntry.operation.operation.renamedIdIntervals)
}

function checkNumberRenameOps (renameOpsPerBot: any[][], nbRenameOps: number): boolean {
    const isNumberOfRenameOpsValid = renameOpsPerBot.every((renameOps: any[]) => renameOps.length === nbRenameOps)
    if (!isNumberOfRenameOpsValid) {
        console.log("checkNumberRenameOps(): observed an invalid number of rename ops")
        renameOpsPerBot.forEach((renameOps, index) => {
            console.log(`${index}: ${renameOps.length}`)
        })
    }
    return isNumberOfRenameOpsValid
}

function checkConcurrence (renameOpsPerBot: any[][], nbRenameOps: number): boolean {
    const vectorsPerBot = renameOpsPerBot.map((renameOps) => renameOps.map((renameOp) => new Map<number, number>(renameOp.vector)))
    let areRenameOpsConcurrent = true
    for (let i = 0; i < nbRenameOps; i++) {
        for (let j = 0; j < vectorsPerBot.length - 1; j++) {
            const currentVector = vectorsPerBot[j][i]
            for (let k = j + 1; k < vectorsPerBot.length; k++) {
                const otherVector = vectorsPerBot[k][i]
                if (!areOpsConcurrent(currentVector, otherVector)) {
                    if (areRenameOpsConcurrent) {
                        console.log("checkConcurrence(): observed causal rename operations")
                        areRenameOpsConcurrent = false
                    }
                    console.log("currentVector: ", currentVector)
                    console.log("otherVector: ", otherVector)
                }
            }
        }
    }
    return areRenameOpsConcurrent
}

export async function checkValidity () {
    const nbBots = 10
    const nbRenameOps = 5

    folders.forEach(async (folder) => {
        const path = `../wip-results/rls-${nbRenamingBots}-renaming-bots/${folder}`
        const areDocsConvergent = await checkConvergence(path, nbBots)
        const renameOpsPerBot = await Promise.all(Array.from({ length: nbRenamingBots }).map((_, index) => retrieveRenameOpsOfBot(path, index)))
        const isNumberOfRenameOpsValid = checkNumberRenameOps(renameOpsPerBot, nbRenameOps)
        if (isNumberOfRenameOpsValid) {
            const areRenameOpsConcurrent = checkConcurrence(renameOpsPerBot, nbRenameOps)
            console.log(`${folder}: areDocsConvergent = ${areDocsConvergent}, isNumberOfRenameOpsValid = true, areRenameOpsConcurrent = ${areRenameOpsConcurrent}`)
        } else {
            console.log(`${folder}: areDocsConvergent = ${areDocsConvergent}, isNumberOfRenameOpsValid = false`)
        }
    })

}
