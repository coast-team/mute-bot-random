import { createWriteStream, readFileSync, WriteStream } from 'fs'
import { LogootSRopes, RenamableLogootSAdd, RenamableReplicableList } from 'mute-structs'
import { mapFolders, random } from './helpers'

function computeIntegrationTimesLS(outputFD: WriteStream, nbOpes: number, folder: string) {
  const folderRoot = `../wip-results/ls`

  const filename = `Snapshot.${nbOpes}.Bot0.json`
  const fullPath = `${folderRoot}/${folder}/${filename}`
  const snapshot = JSON.parse(readFileSync(fullPath, "utf-8"))

  for (let j = 0; j < 100; j++) {
    const seqLocal = LogootSRopes.fromPlain(snapshot) as LogootSRopes
    const seqRemote = LogootSRopes.fromPlain(snapshot) as LogootSRopes

    const index = random(seqLocal.str.length)
    const tLocalStart = process.hrtime.bigint()
    const remoteOp = seqLocal.insertLocal(index, 'I')
    const tLocalEnd = process.hrtime.bigint()

    const tRemoteStart = process.hrtime.bigint()
    remoteOp.execute(seqRemote)
    const tRemoteEnd = process.hrtime.bigint()

    const tLocal = tLocalEnd - tLocalStart
    const tRemote = tRemoteEnd - tRemoteStart

    outputFD.write(`${nbOpes},localLS,${tLocal},0\n`)
    outputFD.write(`${nbOpes},remoteLS,${tRemote},0\n`)
  }
}

function computeIntegrationTimesRLS(outputFD: WriteStream, nbOpes: number, folder: string, nbRenamingBots: number) {
  const folderRoot = `../wip-results/rls-${nbRenamingBots}-renaming-bots`

  const filename = `Snapshot.${nbOpes}.Bot0.json`
  const fullPath = `${folderRoot}/${folder}/${filename}`
  const snapshot = JSON.parse(readFileSync(fullPath, "utf-8"))

  const seq = RenamableReplicableList.fromPlain(snapshot) as RenamableReplicableList
  seq.renamingMapStore.purge()
  const plainSeq = JSON.parse(JSON.stringify(seq))

  for (let j = 0; j < 25; j++) {
    const seqLocal = RenamableReplicableList.fromPlain(plainSeq) as RenamableReplicableList
    const seqRemote = RenamableReplicableList.fromPlain(
      plainSeq
    ) as RenamableReplicableList

    const index = random(seqLocal.str.length)
    const tLocalStart = process.hrtime.bigint()
    const remoteOp = seqLocal.insertLocal(index, 'I')
    const tLocalEnd = process.hrtime.bigint()

    const tRemoteStart = process.hrtime.bigint()
    remoteOp.execute(seqRemote)
    const tRemoteEnd = process.hrtime.bigint()

    const tLocal = tLocalEnd - tLocalStart
    const tRemote = tRemoteEnd - tRemoteStart

    outputFD.write(`${nbOpes},localRLS,${tLocal},${nbRenamingBots}\n`)
    outputFD.write(`${nbOpes},remoteRLS,${tRemote},${nbRenamingBots}\n`)

    if (nbOpes % 30000 === 0) {
      const tRemoteFromPreviousEpoch = computeIntegrationTimeOpFromPreviousEpoch(plainSeq, remoteOp)
      outputFD.write(`${nbOpes},remoteRLSFromPreviousEpoch,${tRemoteFromPreviousEpoch},${nbRenamingBots}\n`)

      const tRemoteFromConcurrentEpoch = computeIntegrationTimeOpFromConcurrentEpoch(plainSeq, index)
      outputFD.write(`${nbOpes},remoteRLSFromConcurrentEpoch,${tRemoteFromConcurrentEpoch},${nbRenamingBots}\n`)
    }
  }
}

function computeIntegrationTimeOpFromPreviousEpoch (plainSeq: any, remoteOp: RenamableLogootSAdd): bigint {
  const seq = RenamableReplicableList.fromPlain(
    plainSeq
  ) as RenamableReplicableList
  seq.renameLocal()

  const tRemoteFromPreviousEpochStart = process.hrtime.bigint()
  remoteOp.execute(seq)
  const tRemoteFromPreviousEpochEnd = process.hrtime.bigint()

  return tRemoteFromPreviousEpochEnd - tRemoteFromPreviousEpochStart
}

function computeIntegrationTimeOpFromConcurrentEpoch (plainSeq: any, index: number): bigint {
  const seqLosing = RenamableReplicableList.fromPlain(
    plainSeq
  ) as RenamableReplicableList
  plainSeq.list.replicaNumber++ // increase replicaNumber to set priority between copies
  const seqWinning = RenamableReplicableList.fromPlain(
    plainSeq
  ) as RenamableReplicableList
  plainSeq.list.replicaNumber-- // restore previous value of replicaNumber

  const renameOpLosing = seqLosing.renameLocal()
  const remoteOpFromConcurrentEpoch = seqLosing.insertLocal(index, 'I')

  seqWinning.renameLocal()
  renameOpLosing.execute(seqWinning)

  const tRemoteFromConcurrentEpochStart = process.hrtime.bigint()
  remoteOpFromConcurrentEpoch.execute(seqWinning)
  const tRemoteFromConcurrentEpochEnd = process.hrtime.bigint()

  return tRemoteFromConcurrentEpochEnd - tRemoteFromConcurrentEpochStart
}

export function computeIntegrationTimesInsertOp () {
  const outputFD = createWriteStream("../wip-results/integration-times-insert-op.csv", { flags: 'a' })
  outputFD.write("nbOpes,type,time,nbRenamingBots\n")

  const foldersLS = mapFolders.get("ls") as string[]

  const steps = Array.from({ length: 15 }, (_, i) => 10000 + i * 10000)
  steps.forEach((nbOpes: number) => {
    foldersLS.forEach((folder) => {
      computeIntegrationTimesLS(outputFD, nbOpes, folder)
    })

    for (let nbRenamingBots = 1; nbRenamingBots < 5; nbRenamingBots++) {
      const foldersRLS = mapFolders.get(`rls-${nbRenamingBots}-renaming-bots`) as string[]
      foldersRLS.forEach((folder) => {
        computeIntegrationTimesRLS(outputFD, nbOpes, folder, nbRenamingBots)
      })
    }
  })
  outputFD.end()
}
