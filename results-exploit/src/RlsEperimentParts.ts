import {
  LogootSOperation,
  RenamableLogootSOperation,
  RenamableReplicableList,
  TextDelete,
  TextInsert,
  TextOperation,
} from 'mute-structs'
const fs = require('fs')

export enum OperationType {
  INSERT,
  DELETE,
}

export interface IRlsLogs {
  local: TextOperation
  remote: RenamableLogootSOperation<LogootSOperation>
  tLocalBefore: [number, number]
  tLocalAfter: [number, number]
  tRemoteBefore: [number, number]
  tRemoteAfter: [number, number]
  tLocalOnRenameBefore: [number, number]
  tLocalOnRenameAfter: [number, number]
  tRemotePastOnRenameBefore: [number, number]
  tRemotePastOnRenameAfter: [number, number]
  tRemoteOnRenameBefore: [number, number]
  tRemoteOnRenameAfter: [number, number]
}

export class RlsExperimentParts {
  private name: string
  private sequence: RenamableReplicableList

  private operationType: OperationType
  private nbChar: number
  private nbTimes: number
  private content: string

  constructor(name: string, sequence: any, type: OperationType, nbChar: number, nbTimes: number) {
    this.name = name
    this.sequence = sequence
    this.operationType = type
    this.nbChar = 0
    this.nbTimes = 0
    this.content = ''

    for (let i = 0; i < nbChar; i++) {
      this.content += 'I'
    }

    this.setNbChar(nbChar)
    this.setNbTimes(nbTimes)
  }

  public launch() {
    console.log(`Start : ${this.name} (${this.operationType}, ${this.nbChar})`)
    const results: IRlsLogs[] = []
    let progress = 5
    const startTime = process.hrtime()
    for (let i = 0; i < this.nbTimes; i++) {
      const seq = RenamableReplicableList.fromPlain(this.sequence)
      if (!seq) {
        throw new Error('Sequence from plain null')
      }
      const local = this.generateLocal(seq.str.length)

      // Apply
      let tLocalBefore: [number, number]
      let tLocalAfter: [number, number]
      let remote: RenamableLogootSOperation<LogootSOperation>

      tLocalBefore = process.hrtime()
      if (local instanceof TextInsert) {
        remote = seq.insertLocal(local.index, local.content)
      } else {
        remote = seq.delLocal(local.index, (local as TextDelete).length)
      }
      tLocalAfter = process.hrtime()

      // Generate the sequence
      const seq2 = RenamableReplicableList.fromPlain(this.sequence)
      if (!seq2) {
        throw new Error('FromPLain Remote is null')
      }

      const tRemoteBefore = process.hrtime()
      remote.execute(seq2)
      const tRemoteAfter = process.hrtime()

      // Renaming
      const seqBeforeRename = RenamableReplicableList.fromPlain(this.sequence)
      if (!seqBeforeRename) {
        throw new Error('FromPLain BeforeRename is null')
      }
      const seqRename = seqBeforeRename.renameLocal()

      // Local on Renamed seq
      const seq3 = RenamableReplicableList.fromPlain(seqRename)
      if (!seq3) {
        throw new Error('Sequence3 from plain null')
      }
      let remote2: RenamableLogootSOperation<LogootSOperation>
      const tLocalOnRenameBefore = process.hrtime()
      if (local instanceof TextInsert) {
        remote2 = seq3.insertLocal(local.index, local.content)
      } else {
        remote2 = seq3.delLocal(local.index, (local as TextDelete).length)
      }
      const tLocalOnRenameAfter = process.hrtime()

      // Remote past epoch on Renamed seq
      const seq4 = RenamableReplicableList.fromPlain(seqRename)
      if (!seq4) {
        throw new Error('Sequence4 from plain null')
      }
      const tRemotePastOnRenameBefore = process.hrtime()
      remote.execute(seq4)
      const tRemotePastOnRenameAfter = process.hrtime()

      // Local on Renamed seq
      const seq5 = RenamableReplicableList.fromPlain(seqRename)
      if (!seq5) {
        throw new Error('Sequence5 from plain null')
      }
      const tRemoteOnRenameBefore = process.hrtime()
      remote2.execute(seq5)
      const tRemoteOnRenameAfter = process.hrtime()

      // PUSH RESULTS
      results.push({
        local,
        remote,
        tLocalBefore,
        tLocalAfter,
        tRemoteBefore,
        tRemoteAfter,
        tLocalOnRenameBefore,
        tLocalOnRenameAfter,
        tRemotePastOnRenameBefore,
        tRemotePastOnRenameAfter,
        tRemoteOnRenameBefore,
        tRemoteOnRenameAfter,
      })
      const percent = Math.floor(((i + 1) / this.nbTimes) * 100)
      if (percent > 0 && percent % progress === 0) {
        const progressTime = process.hrtime(startTime)
        console.log('Progress :', percent, `(${i + 1}/${this.nbTimes} in ${progressTime})`)
        progress += 5
      }
    }
    const stopTime = process.hrtime(startTime)

    fs.writeFileSync(`output/${this.name}.json`, JSON.stringify(results))
    console.log(`End : ${this.name} in ${stopTime}s`)
  }

  private generateLocal(indexMax: number): TextOperation {
    switch (this.operationType) {
      case OperationType.INSERT:
        const iIndex = this.random(indexMax)
        return new TextInsert(iIndex, this.content, 1000)
      case OperationType.DELETE:
        const dIndex = this.random(indexMax - this.nbChar)
        return new TextDelete(dIndex, this.nbChar, 1000)
      default:
        throw new Error(`Type ${this.operationType} doesn't exist.`)
    }
  }

  private random(max: number) {
    return Math.floor(Math.random() * (max + 1))
  }

  private setNbChar(nb: number) {
    if (nb > 0) {
      this.nbChar = nb
    } else {
      console.log('Error : nbChar <= 0 ... set to 1')
      this.nbChar = 1
    }
  }

  private setNbTimes(nb: number) {
    if (nb > 0) {
      this.nbTimes = nb
    } else {
      console.log('Error : nbTimes <= 0 ... set to 100')
      this.nbTimes = 100
    }
  }
}
